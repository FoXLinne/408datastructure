//树 -> 二叉树
    //1. 使用孩子兄弟表示法
    //2. 在二叉树中画出根结点
    //3. 按照树的层次依次处理结点

//二叉树 -> 树 / 森林
    //反向操作

//树的遍历
    //1. 先根遍历（深度优先遍历）
    //若树非空，先访问根结点，再依次对子树进行遍历
    void PreOrder(TreeNode *R){
        if(R != NULL){
            visit(R);
            while(还存在子树T){
                PreOrder(T);
            }
        }
    }
    //先根遍历序列与转换后与之对应的二叉树先序遍历序列相同

    //2. 后根遍历（深度优先遍历）
    //若树非空，则先遍历每个子树，最后再访问根结点
    void PostOrder(TreeNode *R){
        if (R != NULL){
            while (还存在子树T){
                PostOrder(T);
            }
            visit(R);
        }
    }
    //后根遍历序列与转换后与之对应的二叉树中序遍历序列相同

    //3. 层次遍历（广度优先遍历）
    //1. 若树非空，则根结点入队
    //2. 若队列非空，则队头元素出队并访问，将该元素的孩子依次入列
    //3. 重复2直至队列为空

//森林的遍历
    //1. 先序遍历
    //若森林非空，首先访问森林里第一棵树的根结点
    //先序遍历第一棵树根结点的子树森林
    //先序遍历除去第一棵树后剩余的树构成的森林
    //等同于对各个树依次进行先根遍历
    //或将森林转换为二叉树，进行二叉树的先序遍历序列

    //2. 中序遍历
    //中序遍历森林中第一棵树的根结点的子树森林
    //访问第一棵树的根节点
    //中序遍历除去第一棵树后剩余的树构成的森林
    //等同于对二叉树进行中序遍历